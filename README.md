# 동시성 제어 방식에 대한 분석 및 보고서

## 포인트 시스템에서 해결하고자 한 동시성 문제

### 한 명의 유저가 동시에 여러 요청을 했을 때 정상적으로 처리된다

- **방지하고자 하는 상황: 레이스 컨디션, 업데이트 유실, 데이터 일관성 보장 못함 해결**
  - 서로 다른 요청이 실행되는 시점에 따라 조회되는 정보가 달라지기 때문에 저장되는 정보도 달라진다.
  - 만약에 다른 요청이 정보를 조회한 시점에 또 다른 요청이 정보를 조회하면 서로 같은 정보를 읽어와서 정보를 덮어씌우게 된다.

### 서로 다른 유저가 동시에 여러 요청을 했을 때 정상적으로 처리된다

- **방지하고자 하는 상황: 레이스 컨디션, 데드락, 더티 리드, 업데이트 유실**
  - 서로 다른 유저에 대한 요청은 격리되어 각자의 트랜잭션에 영향을 끼치면 안 된다.
  - 하지만 동시에 요청이 실행될 경우, 공유 자원에 대해 동시에 락 획득 시도 시에 충돌이 일어날 수 있다.

---

## 채택한 동시성 제어 방식

**서비스 단에서 글로벌 락으로 제어하여 모든 로직들이 한 번에 하나씩 실행됨**

### 글로벌 락을 선택한 이유

- **공유 자원 보호:** 서로 다른 쓰레드가 같은 포인트 정보를 가져올 때 순서대로 가져오게 함
- **Atomic Operation을 보장:** 서로 다른 요청이 데이터를 커밋했을 때 덮어씌워지거나 유실되는 것을 방지함

#### 단점

- **성능 Bottleneck:** 운영에 배포되는 코드라 가정하지 않아 해당사항 없음
- **스케일링 이슈:** 운영에 배포되는 코드라 가정하지 않아 해당사항 없음
- **데드락 이슈:** 대부분의 케이스에는 해당하지 않지만, 소수의 케이스에서 락을 서로 다른 순서로 획득 시도 시에 데드락이 발생할 수 있음

### 트랜잭션 관리 방식

- **매뉴얼 락 관리:** 어플리케이션 코드에 락을 수동 설정하였음. 상호 배제 락을 통해 레이스 컨디션, 업데이트 유실, 데이터 비일관성을 해결하고자 함
- **글로벌 락:** 하나의 락이 모든 작업 또는 자원을 관리. 싱글톤으로 생성된 락 매니저가 모든 쓰레드들을 관리하여 중요한 로직에 대해 보장함

### 코드 샘플

```kotlin
@Component
class LockManager {
    private val lock = ReentrantLock()

    fun <T> executeWithLock(block: () -> T): T {
        return lock.withLock {
            block()
        }
    }
}

override fun charge(command: ChargePointCommand): UserPoint {
    return lockManager.executeWithLock {
        chargePointCommandValidator.validate(command)
        val modifiedCommand = chargePointCommandPreModifier.modify(command)
        userPointRepository.charge(modifiedCommand)
    }
}
```

---

## 사용한 라이브러리

### Reentrant Lock

- **ReentrantLock:** 자바의 `concurrent` 패키지에 속한 상호 배제 락. 동시에 여러 스레드가 동일한 자원에 접근하는 것을 방지.
  - **재진입성:** 동일한 스레드가 동일한 락을 여러 번 획득할 수 있다. 데드락 방지에 효과적.
  - **상호 배제:** 오직 하나의 스레드만 임계 구역에 진입할 수 있다.
  - **공정성:** 요청한 순서대로 락 획득하는 것을 보장
  - **락 해제:** 임계 구역을 벗어났을 때 락 해제

---

## 데이터 무결성 및 일관성

- **데이터 무결성과 일관성을 보장하기 위해 강한 일관성 모델을 지원하기 위해 락 기반 동시성 제어를 사용함**

---

## 다른 대안 검토한 것

### 큐 (Queue)

- **장점:** 작업을 순차적으로 처리할 수 있는 장점이 있음.
- **단점:** 프로젝트 작업에 비해 오버 엔지니어링이라 판단해 도입하지 않음

### 레디스 (Redis)

- **장점:** 분산 락으로 동시성 문제를 해결할 수 있음.
- **단점:** 분산 환경을 고려하지 않아 도입하지 않음

### 유저별 락 (Per-User Locks)

- **장점:** 사용자 별로 락을 획득할 수 있어 높은 동시성을 유지 가능.
- **단점:** 관리 복잡성을 고려하여 도입하지 않음

### 결론

- **초기 구현의 단순성과 안정성을 고려하여 글로벌 락을 채택함. 만일 실제 환경이었다면 낙관적 락 도입을 고려하고, 추이를 치겨본 후 비관적 락 또는 분산 락을 도입할지 검토할 것임**

---

## 테스트 방식

### 단위 테스트 (Unit Testing)

- **단위 테스트에서는 객체의 의존성을 모두 배제하고, 순수하게 객체의 기능만을 테스트하는 것에 집중함.**

### 통합 테스트 (Integration Testing)

- **테스트 환경으로 구동하여 동시성에 관한 문제들을 잘 해결했는지 테스트 케이스들을 통해 검증하려 함**
- **의존성들이 제대로 주입이 됐는지 검증함**
